# è¿æ¥æ± å®Œæ•´è§£æ

## ğŸ“‹ ç›®å½•
1. [è®¾è®¡æ€æƒ³](#è®¾è®¡æ€æƒ³)
2. [æ ¸å¿ƒç‰¹æ€§](#æ ¸å¿ƒç‰¹æ€§)
3. [ä¸ç°æœ‰ä»£ç å¯¹æ¯”](#ä¸ç°æœ‰ä»£ç å¯¹æ¯”)
4. [ä½¿ç”¨ç¤ºä¾‹](#ä½¿ç”¨ç¤ºä¾‹)
5. [é«˜çº§ç”¨æ³•](#é«˜çº§ç”¨æ³•)
6. [æ€§èƒ½ä¼˜åŠ¿](#æ€§èƒ½ä¼˜åŠ¿)
7. [å®é™…åº”ç”¨](#å®é™…åº”ç”¨)

---

## ğŸ§  è®¾è®¡æ€æƒ³

### æ ¸å¿ƒæ¦‚å¿µ
è¿æ¥æ± é‡‡ç”¨**æ¨¡æ¿åŒ–è®¾è®¡**å’Œ**å·¥å‚æ¨¡å¼**ï¼Œå®ç°äº†ä¸€ä¸ªé€šç”¨çš„è¿æ¥ç®¡ç†æ¡†æ¶ï¼Œå¯ä»¥é€‚é…ä»»ä½•ç±»å‹çš„è¿æ¥ã€‚

### è®¾è®¡åŸåˆ™
1. **é€šç”¨æ€§**ï¼šä¸€å¥—ä»£ç é€‚é…å¤šç§è¿æ¥ç±»å‹
2. **ç±»å‹å®‰å…¨**ï¼šç¼–è¯‘æ—¶æ£€æŸ¥è¿æ¥ç±»å‹
3. **èµ„æºå¤ç”¨**ï¼šé¿å…é¢‘ç¹åˆ›å»º/é”€æ¯è¿æ¥
4. **å¼‚å¸¸å®‰å…¨**ï¼šRAII èµ„æºç®¡ç†
5. **çº¿ç¨‹å®‰å…¨**ï¼šæ”¯æŒå¤šçº¿ç¨‹å¹¶å‘è®¿é—®

---

## ğŸ—ï¸ æ ¸å¿ƒç‰¹æ€§

### 1. æ¨¡æ¿åŒ–è®¾è®¡
```cpp
template<typename ConnectionType>
class ConnectionPool : public Singleton<ConnectionPool<ConnectionType>>
```

**ä¼˜åŠ¿ï¼š**
- **ç±»å‹å®‰å…¨**ï¼šç¼–è¯‘æ—¶æ£€æŸ¥è¿æ¥ç±»å‹
- **ä»£ç å¤ç”¨**ï¼šä¸€å¥—ä»£ç é€‚é…å¤šç§è¿æ¥
- **çµæ´»æ€§**ï¼šæ”¯æŒä»»ä½•è‡ªå®šä¹‰è¿æ¥ç±»å‹

### 2. å·¥å‚æ¨¡å¼
```cpp
using ConnectionFactory = std::function<ConnectionPtr()>;
void Initialize(size_t poolSize, ConnectionFactory factory);
```

**ä½œç”¨ï¼š**
- **è§£è€¦**ï¼šè¿æ¥åˆ›å»ºé€»è¾‘ä¸æ± ç®¡ç†åˆ†ç¦»
- **å¯é…ç½®**ï¼šè¿è¡Œæ—¶å†³å®šå¦‚ä½•åˆ›å»ºè¿æ¥
- **å¯æ‰©å±•**ï¼šæ”¯æŒä¸åŒçš„è¿æ¥åˆ›å»ºç­–ç•¥

### 3. æ ¸å¿ƒæ“ä½œ
```cpp
ConnectionPtr GetConnection();        // è·å–è¿æ¥
void ReturnConnection(ConnectionPtr); // å½’è¿˜è¿æ¥
void Close();                         // å…³é—­æ± 
size_t GetAvailableCount() const;     // å¯ç”¨è¿æ¥æ•°
size_t GetInUseCount() const;         // ä½¿ç”¨ä¸­è¿æ¥æ•°
```

---

## ğŸ”„ ä¸ç°æœ‰ä»£ç å¯¹æ¯”

### 1. MySQL è¿æ¥æ± å¯¹æ¯”

#### ä½ ç°æœ‰çš„å®ç°
```cpp
class MySqlPool {
private:
    std::queue<std::unique_ptr<SqlConnection>> pool_;
    std::mutex mutex_;
    std::condition_variable cond_;
    std::atomic<bool> b_stop_;
    
public:
    std::unique_ptr<SqlConnection> getConnection() {
        std::unique_lock<std::mutex> lock(mutex_);
        cond_.wait(lock, [this] { 
            return b_stop_ || !pool_.empty(); 
        });
        if (b_stop_) return nullptr;
        
        auto con = std::move(pool_.front());
        pool_.pop();
        return con;
    }
};
```

#### ä½¿ç”¨æˆ‘çš„é€šç”¨è¿æ¥æ± 
```cpp
// å®šä¹‰ MySQL è¿æ¥ç±»å‹
class MySQLConnection {
public:
    MySQLConnection(const std::string& url, const std::string& user, 
                   const std::string& pass, const std::string& schema);
    bool Execute(const std::string& sql);
    bool IsValid() const;
    void Close();
};

// ä½¿ç”¨è¿æ¥æ± 
using MySQLPool = ConnectionPool<MySQLConnection>;

// åˆå§‹åŒ–
auto mysqlPool = MySQLPool::GetInstance();
mysqlPool.Initialize(10, []() {
    return std::make_shared<MySQLConnection>("localhost", "user", "pass", "db");
});

// ä½¿ç”¨
auto conn = mysqlPool.GetConnection();
conn->Execute("SELECT * FROM users");
mysqlPool.ReturnConnection(conn);
```

### 2. Redis è¿æ¥æ± å¯¹æ¯”

#### ä½ ç°æœ‰çš„å®ç°
```cpp
class RedisConPool {
private:
    std::queue<redisContext*> connections_;
    std::mutex mutex_;
    std::condition_variable cond_;
    
public:
    redisContext* getConnection() {
        std::unique_lock<std::mutex> lock(mutex_);
        cond_.wait(lock, [this] { 
            return b_stop_ || !connections_.empty(); 
        });
        if (b_stop_) return nullptr;
        
        auto context = connections_.front();
        connections_.pop();
        return context;
    }
};
```

#### ä½¿ç”¨æˆ‘çš„é€šç”¨è¿æ¥æ± 
```cpp
// å®šä¹‰ Redis è¿æ¥ç±»å‹
class RedisConnection {
public:
    RedisConnection(const std::string& host, int port, const std::string& password);
    bool Execute(const std::string& command);
    bool IsValid() const;
    void Close();
};

// ä½¿ç”¨è¿æ¥æ± 
using RedisPool = ConnectionPool<RedisConnection>;

// åˆå§‹åŒ–
auto redisPool = RedisPool::GetInstance();
redisPool.Initialize(5, []() {
    return std::make_shared<RedisConnection>("localhost", 6379, "password");
});

// ä½¿ç”¨
auto conn = redisPool.GetConnection();
conn->Execute("SET key value");
redisPool.ReturnConnection(conn);
```

### 3. å¯¹æ¯”æ€»ç»“

| ç‰¹æ€§ | ç°æœ‰å®ç° | é€šç”¨è¿æ¥æ±  |
|------|----------|------------|
| ä»£ç å¤ç”¨ | æ¯ç§è¿æ¥ç±»å‹éœ€è¦å•ç‹¬å®ç° | ä¸€å¥—ä»£ç é€‚é…æ‰€æœ‰ç±»å‹ |
| ç±»å‹å®‰å…¨ | è¿è¡Œæ—¶æ£€æŸ¥ | ç¼–è¯‘æ—¶æ£€æŸ¥ |
| ç»´æŠ¤æˆæœ¬ | é«˜ï¼ˆå¤šä¸ªç›¸ä¼¼ç±»ï¼‰ | ä½ï¼ˆç»Ÿä¸€ç®¡ç†ï¼‰ |
| æ‰©å±•æ€§ | å·®ï¼ˆç¡¬ç¼–ç ï¼‰ | å¥½ï¼ˆæ¨¡æ¿åŒ–ï¼‰ |
| æµ‹è¯•éš¾åº¦ | é«˜ï¼ˆéœ€è¦æµ‹è¯•å¤šä¸ªç±»ï¼‰ | ä½ï¼ˆæµ‹è¯•ä¸€ä¸ªæ¨¡æ¿ç±»ï¼‰ |

---

## ğŸ“ ä½¿ç”¨ç¤ºä¾‹

### 1. MySQL è¿æ¥æ± 

```cpp
// å®šä¹‰ MySQL è¿æ¥ç±»
class MySQLConnection {
public:
    MySQLConnection(const std::string& url, const std::string& user, 
                   const std::string& pass, const std::string& schema) {
        // åˆ›å»º MySQL è¿æ¥
        sql::mysql::MySQL_Driver* driver = sql::mysql::get_mysql_driver_instance();
        _connection = std::unique_ptr<sql::Connection>(driver->connect(url, user, pass));
        _connection->setSchema(schema);
        _isValid = true;
    }
    
    bool Execute(const std::string& sql) {
        if (!_isValid) return false;
        try {
            std::unique_ptr<sql::Statement> stmt(_connection->createStatement());
            stmt->execute(sql);
            return true;
        } catch (const sql::SQLException& e) {
            _isValid = false;
            return false;
        }
    }
    
    bool IsValid() const { return _isValid; }
    void Close() { _isValid = false; _connection.reset(); }
    
private:
    std::unique_ptr<sql::Connection> _connection;
    bool _isValid;
};

// ä½¿ç”¨è¿æ¥æ± 
void MySQLExample() {
    auto& mysqlPool = ConnectionPool<MySQLConnection>::GetInstance();
    
    // åˆå§‹åŒ–
    mysqlPool.Initialize(5, []() {
        return std::make_shared<MySQLConnection>("localhost:3306", "user", "pass", "mydb");
    });
    
    // ä½¿ç”¨è¿æ¥
    auto conn = mysqlPool.GetConnection();
    if (conn) {
        conn->Execute("SELECT * FROM users LIMIT 10");
        mysqlPool.ReturnConnection(conn);
    }
}
```

### 2. Redis è¿æ¥æ± 

```cpp
// å®šä¹‰ Redis è¿æ¥ç±»
class RedisConnection {
public:
    RedisConnection(const std::string& host, int port, const std::string& password) {
        _context = redisConnect(host.c_str(), port);
        if (_context && _context->err == 0) {
            if (!password.empty()) {
                auto reply = (redisReply*)redisCommand(_context, "AUTH %s", password.c_str());
                if (reply->type == REDIS_REPLY_ERROR) {
                    freeReplyObject(reply);
                    throw std::runtime_error("Redis authentication failed");
                }
                freeReplyObject(reply);
            }
            _isValid = true;
        }
    }
    
    bool Execute(const std::string& command) {
        if (!_isValid) return false;
        try {
            auto reply = (redisReply*)redisCommand(_context, command.c_str());
            if (reply) {
                freeReplyObject(reply);
                return true;
            }
            return false;
        } catch (...) {
            _isValid = false;
            return false;
        }
    }
    
    bool IsValid() const { return _isValid; }
    void Close() { 
        if (_context) {
            redisFree(_context);
            _context = nullptr;
        }
        _isValid = false;
    }
    
private:
    redisContext* _context;
    bool _isValid;
};

// ä½¿ç”¨è¿æ¥æ± 
void RedisExample() {
    auto& redisPool = ConnectionPool<RedisConnection>::GetInstance();
    
    // åˆå§‹åŒ–
    redisPool.Initialize(3, []() {
        return std::make_shared<RedisConnection>("localhost", 6379, "password");
    });
    
    // ä½¿ç”¨è¿æ¥
    auto conn = redisPool.GetConnection();
    if (conn) {
        conn->Execute("SET key value");
        redisPool.ReturnConnection(conn);
    }
}
```

### 3. HTTP è¿æ¥æ± 

```cpp
// å®šä¹‰ HTTP è¿æ¥ç±»
class HttpConnection {
public:
    HttpConnection(const std::string& host, int port) {
        // ä½¿ç”¨ Boost.Beast æˆ–å…¶ä»– HTTP å®¢æˆ·ç«¯åº“
        _isValid = true;
    }
    
    bool Execute(const std::string& request) {
        if (!_isValid) return false;
        // å‘é€ HTTP è¯·æ±‚
        return true;
    }
    
    bool IsValid() const { return _isValid; }
    void Close() { _isValid = false; }
    
private:
    bool _isValid;
};

// ä½¿ç”¨è¿æ¥æ± 
void HttpExample() {
    auto& httpPool = ConnectionPool<HttpConnection>::GetInstance();
    
    // åˆå§‹åŒ–
    httpPool.Initialize(4, []() {
        return std::make_shared<HttpConnection>("api.example.com", 80);
    });
    
    // ä½¿ç”¨è¿æ¥
    auto conn = httpPool.GetConnection();
    if (conn) {
        conn->Execute("GET /api/data HTTP/1.1");
        httpPool.ReturnConnection(conn);
    }
}
```

---

## ğŸš€ é«˜çº§ç”¨æ³•

### 1. å¤šæ•°æ®åº“ç®¡ç†å™¨

```cpp
class DatabaseManager {
private:
    ConnectionPool<MySQLConnection> _mysqlPool;
    ConnectionPool<RedisConnection> _redisPool;
    ConnectionPool<HttpConnection> _httpPool;
    
public:
    DatabaseManager() {
        // åˆå§‹åŒ– MySQL è¿æ¥æ± 
        _mysqlPool.Initialize(5, []() {
            return std::make_shared<MySQLConnection>("localhost:3306", "user", "pass", "db");
        });
        
        // åˆå§‹åŒ– Redis è¿æ¥æ± 
        _redisPool.Initialize(3, []() {
            return std::make_shared<RedisConnection>("localhost", 6379, "pass");
        });
        
        // åˆå§‹åŒ– HTTP è¿æ¥æ± 
        _httpPool.Initialize(4, []() {
            return std::make_shared<HttpConnection>("api.example.com", 80);
        });
    }
    
    // äº‹åŠ¡æ“ä½œç¤ºä¾‹
    bool ProcessUserRegistration(const std::string& username, const std::string& email) {
        // è·å– MySQL è¿æ¥
        auto mysqlConn = _mysqlPool.GetConnection();
        if (!mysqlConn) return false;
        
        // è·å– Redis è¿æ¥
        auto redisConn = _redisPool.GetConnection();
        if (!redisConn) {
            _mysqlPool.ReturnConnection(mysqlConn);
            return false;
        }
        
        try {
            // åœ¨ MySQL ä¸­æ’å…¥ç”¨æˆ·
            mysqlConn->Execute("INSERT INTO users (username, email) VALUES ('" + username + "', '" + email + "')");
            
            // åœ¨ Redis ä¸­ç¼“å­˜ç”¨æˆ·ä¿¡æ¯
            redisConn->Execute("SET user:" + username + " " + email);
            
            // å½’è¿˜è¿æ¥
            _mysqlPool.ReturnConnection(mysqlConn);
            _redisPool.ReturnConnection(redisConn);
            
            return true;
        } catch (...) {
            // å½’è¿˜è¿æ¥
            _mysqlPool.ReturnConnection(mysqlConn);
            _redisPool.ReturnConnection(redisConn);
            return false;
        }
    }
    
    void Close() {
        _mysqlPool.Close();
        _redisPool.Close();
        _httpPool.Close();
    }
};
```

### 2. è¿æ¥å¥åº·æ£€æŸ¥

```cpp
template<typename ConnectionType>
class HealthCheckableConnection : public ConnectionType {
public:
    template<typename... Args>
    HealthCheckableConnection(Args&&... args) 
        : ConnectionType(std::forward<Args>(args)...) {}
    
    virtual bool Ping() = 0;
};

class MySQLConnectionWithHealthCheck : public HealthCheckableConnection<MySQLConnection> {
public:
    MySQLConnectionWithHealthCheck(const std::string& url, const std::string& user, 
                                  const std::string& pass, const std::string& schema)
        : HealthCheckableConnection(url, user, pass, schema) {}
    
    bool Ping() override {
        return Execute("SELECT 1");
    }
};

// ä½¿ç”¨å¸¦å¥åº·æ£€æŸ¥çš„è¿æ¥æ± 
void HealthCheckExample() {
    auto& mysqlPool = ConnectionPool<MySQLConnectionWithHealthCheck>::GetInstance();
    
    mysqlPool.Initialize(5, []() {
        return std::make_shared<MySQLConnectionWithHealthCheck>("localhost", "user", "pass", "db");
    });
    
    // å®šæœŸå¥åº·æ£€æŸ¥
    auto conn = mysqlPool.GetConnection();
    if (conn && conn->Ping()) {
        // è¿æ¥å¥åº·ï¼Œå¯ä»¥ä½¿ç”¨
        conn->Execute("SELECT * FROM users");
        mysqlPool.ReturnConnection(conn);
    } else {
        // è¿æ¥ä¸å¥åº·ï¼Œä¸¢å¼ƒ
        LOG_WARNING("Unhealthy connection detected");
    }
}
```

### 3. è¿æ¥æ± ç›‘æ§

```cpp
template<typename ConnectionType>
class MonitoredConnectionPool : public ConnectionPool<ConnectionType> {
public:
    struct PoolStats {
        size_t totalConnections;
        size_t availableConnections;
        size_t inUseConnections;
        size_t failedConnections;
        double averageWaitTime;
    };
    
    PoolStats GetStats() const {
        PoolStats stats;
        stats.totalConnections = this->GetPoolSize();
        stats.availableConnections = this->GetAvailableCount();
        stats.inUseConnections = this->GetInUseCount();
        // å…¶ä»–ç»Ÿè®¡ä¿¡æ¯...
        return stats;
    }
    
    void LogStats() {
        auto stats = GetStats();
        LOG_INFO("Pool Stats - Total: {}, Available: {}, InUse: {}, Failed: {}", 
                 stats.totalConnections, stats.availableConnections, 
                 stats.inUseConnections, stats.failedConnections);
    }
};
```

---

## âš¡ æ€§èƒ½ä¼˜åŠ¿

### 1. è¿æ¥å¤ç”¨ vs ä¼ ç»Ÿæ–¹å¼

```mermaid
graph LR
    A[ä¼ ç»Ÿæ–¹å¼] --> B[åˆ›å»ºè¿æ¥]
    B --> C[æ‰§è¡Œæ“ä½œ]
    C --> D[é”€æ¯è¿æ¥]
    
    E[è¿æ¥æ± æ–¹å¼] --> F[å¤ç”¨è¿æ¥]
    F --> G[æ‰§è¡Œæ“ä½œ]
    G --> F
    
    style A fill:#ffebee
    style E fill:#e8f5e8
```

### 2. æ€§èƒ½å¯¹æ¯”

| æŒ‡æ ‡ | ä¼ ç»Ÿæ–¹å¼ | è¿æ¥æ± æ–¹å¼ |
|------|----------|------------|
| è¿æ¥åˆ›å»ºå¼€é”€ | é«˜ | ä½ |
| å†…å­˜ä½¿ç”¨ | é«˜ | ä½ |
| å“åº”æ—¶é—´ | æ…¢ | å¿« |
| å¹¶å‘èƒ½åŠ› | ä½ | é«˜ |
| èµ„æºç®¡ç† | å¤æ‚ | ç®€å• |

### 3. é€‚ç”¨åœºæ™¯

- **é«˜å¹¶å‘ç³»ç»Ÿ**ï¼šå‡å°‘è¿æ¥åˆ›å»ºå¼€é”€
- **æ•°æ®åº“åº”ç”¨**ï¼šæé«˜æŸ¥è¯¢æ€§èƒ½
- **å¾®æœåŠ¡æ¶æ„**ï¼šç®¡ç†æœåŠ¡é—´è¿æ¥
- **å®æ—¶ç³»ç»Ÿ**ï¼šå‡å°‘å»¶è¿Ÿ

---

## ğŸ¯ å®é™…åº”ç”¨

### 1. åœ¨ä½ çš„é¡¹ç›®ä¸­çš„åº”ç”¨

#### æ›¿æ¢ç°æœ‰çš„ MySQL è¿æ¥æ± 
```cpp
// æ›¿æ¢ MySqlPool
class MysqlDao {
private:
    ConnectionPool<MySQLConnection> _pool;
    
public:
    MysqlDao() {
        _pool.Initialize(10, []() {
            return std::make_shared<MySQLConnection>("localhost", "user", "pass", "schema");
        });
    }
    
    int RegUser(const std::string& name, const std::string& email, const std::string& pwd) {
        auto conn = _pool.GetConnection();
        if (!conn) return -1;
        
        try {
            conn->Execute("INSERT INTO users (name, email, pwd) VALUES ('" + name + "', '" + email + "', '" + pwd + "')");
            _pool.ReturnConnection(conn);
            return 0;
        } catch (...) {
            _pool.ReturnConnection(conn);
            return -1;
        }
    }
};
```

#### æ›¿æ¢ç°æœ‰çš„ Redis è¿æ¥æ± 
```cpp
// æ›¿æ¢ RedisConPool
class RedisMgr : public Singleton<RedisMgr> {
private:
    ConnectionPool<RedisConnection> _pool;
    
public:
    bool Get(const std::string& key, std::string& value) {
        auto conn = _pool.GetConnection();
        if (!conn) return false;
        
        try {
            conn->Execute("GET " + key);
            _pool.ReturnConnection(conn);
            return true;
        } catch (...) {
            _pool.ReturnConnection(conn);
            return false;
        }
    }
};
```

### 2. ç½‘å…³æœåŠ¡å™¨ä¸­çš„åº”ç”¨

```cpp
class GateServer {
private:
    ConnectionPool<HttpConnection> _httpPool;
    ConnectionPool<gRPCConnection> _grpcPool;
    
public:
    void HandleRequest(const HttpRequest& req) {
        // å¤„ç† HTTP è¯·æ±‚
        auto httpConn = _httpPool.GetConnection();
        if (httpConn) {
            httpConn->Execute(req.ToString());
            _httpPool.ReturnConnection(httpConn);
        }
        
        // è°ƒç”¨å…¶ä»–æœåŠ¡
        auto grpcConn = _grpcPool.GetConnection();
        if (grpcConn) {
            grpcConn->Execute(req.ToGRPCRequest());
            _grpcPool.ReturnConnection(grpcConn);
        }
    }
};
```

### 3. èŠå¤©æœåŠ¡å™¨ä¸­çš„åº”ç”¨

```cpp
class ChatServer {
private:
    ConnectionPool<MySQLConnection> _mysqlPool;
    ConnectionPool<RedisConnection> _redisPool;
    
public:
    void ProcessMessage(const ChatMessage& msg) {
        // å­˜å‚¨æ¶ˆæ¯åˆ° MySQL
        auto mysqlConn = _mysqlPool.GetConnection();
        if (mysqlConn) {
            mysqlConn->Execute("INSERT INTO messages (user_id, content, timestamp) VALUES (" + 
                              std::to_string(msg.userId) + ", '" + msg.content + "', NOW())");
            _mysqlPool.ReturnConnection(mysqlConn);
        }
        
        // ç¼“å­˜ç”¨æˆ·çŠ¶æ€åˆ° Redis
        auto redisConn = _redisPool.GetConnection();
        if (redisConn) {
            redisConn->Execute("SET user:" + std::to_string(msg.userId) + ":last_active " + 
                              std::to_string(std::time(nullptr)));
            _redisPool.ReturnConnection(redisConn);
        }
    }
};
```

---

## ğŸ† æ€»ç»“

### æ ¸å¿ƒä¼˜åŠ¿
1. **é€šç”¨æ€§**ï¼šä¸€å¥—ä»£ç é€‚é…å¤šç§è¿æ¥ç±»å‹
2. **ç±»å‹å®‰å…¨**ï¼šç¼–è¯‘æ—¶æ£€æŸ¥ï¼Œé¿å…è¿è¡Œæ—¶é”™è¯¯
3. **é«˜æ€§èƒ½**ï¼šè¿æ¥å¤ç”¨ï¼Œå‡å°‘åˆ›å»ºå¼€é”€
4. **æ˜“ç»´æŠ¤**ï¼šç»Ÿä¸€çš„ç®¡ç†æ¥å£
5. **å¯æ‰©å±•**ï¼šæ”¯æŒè‡ªå®šä¹‰è¿æ¥ç±»å‹

### è®¾è®¡äº®ç‚¹
1. **æ¨¡æ¿åŒ–è®¾è®¡**ï¼šç±»å‹å®‰å…¨çš„é€šç”¨å®ç°
2. **å·¥å‚æ¨¡å¼**ï¼šçµæ´»çš„è¿æ¥åˆ›å»ºç­–ç•¥
3. **RAII ç®¡ç†**ï¼šè‡ªåŠ¨èµ„æºç®¡ç†
4. **çº¿ç¨‹å®‰å…¨**ï¼šæ”¯æŒå¤šçº¿ç¨‹å¹¶å‘
5. **å¼‚å¸¸å®‰å…¨**ï¼šå¼ºå¼‚å¸¸å®‰å…¨ä¿è¯

### åº”ç”¨ä»·å€¼
- **ç®€åŒ–ä»£ç **ï¼šå‡å°‘é‡å¤çš„è¿æ¥æ± å®ç°
- **æé«˜æ€§èƒ½**ï¼šè¿æ¥å¤ç”¨å’Œèµ„æºç®¡ç†
- **å¢å¼ºå¯é æ€§**ï¼šç»Ÿä¸€çš„é”™è¯¯å¤„ç†å’Œèµ„æºç®¡ç†
- **ä¾¿äºæµ‹è¯•**ï¼šç»Ÿä¸€çš„æ¥å£ä¾¿äºå•å…ƒæµ‹è¯•
- **æ˜“äºæ‰©å±•**ï¼šæ”¯æŒæ–°çš„è¿æ¥ç±»å‹

è¿™ä¸ªé€šç”¨è¿æ¥æ± è®¾è®¡ä¸ä»…è§£å†³äº†ä½ ç°æœ‰ä»£ç ä¸­çš„é‡å¤é—®é¢˜ï¼Œè¿˜ä¸ºæœªæ¥çš„æ‰©å±•æä¾›äº†è‰¯å¥½çš„åŸºç¡€ã€‚å®ƒå±•ç¤ºäº†ç°ä»£C++æ¨¡æ¿ç¼–ç¨‹å’Œè®¾è®¡æ¨¡å¼çš„å¼ºå¤§èƒ½åŠ›ï¼ğŸš€ 